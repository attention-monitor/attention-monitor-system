# 论文公式14 → 代码实现详解

## 公式回顾

$$S_{att}(t) = S_{base} - \sum_{i=1}^{n} \delta_{i,t} - \lambda \sum_{j=1}^{N} \eta_j \cdot \hat{y}_j(t)$$

下面逐项拆解这个公式在代码中的实现。

---

## 第一项：S_base（基准分）

**论文含义：** 理想学习专注状态的满分基准，通常设为100。

**代码位置：** `calculate_attention_score()`（第3484行）

```python
# 计算基础总分
base_score = (
    eye_score + gaze_score + head_score +
    duration_score + blink_score + motor_score
)
```

代码并不是从100开始扣分，而是换了一种等价思路：**6个维度各自从0分开始"挣分"，加起来凑满100**。这和"从100开始扣分"在数学上等价，只是方向反了。6个维度的满分加起来 = 25+20+15+20+10+10 = **100分**，就是论文中的 S_base。

---

## 第二项：Σδ_{i,t}（行为扣分项）

**论文含义：** δ_{i,t} 是第 i 个行为维度在时刻 t 的"偏离强度"，越偏离正常状态扣分越多。

论文公式13给出了δ的计算方式：

$$\delta_{i,t} = \omega_i \cdot \sqrt{\frac{1}{T}\sum_{\tau=t-T}^{t}\left(\|u_\tau - \bar{u}\|^2 + \gamma \cdot (EAR_\tau - \overline{EAR})^2\right)}$$

在代码中，这个"偏离强度"被分解为 **6个子评分函数**，每个函数内部衡量"你离理想状态差多少"：

---

### δ₁：眼部睁开度偏离 → `calculate_eye_score_optimized()`（第3587行）

**满分25分。EAR越低 → 眼睛越闭 → 得分越少（即"扣分"越多）。**

```python
def calculate_eye_score_optimized(self, ear_left, ear_right, attention_label):
    # 闭眼直接0分
    if attention_label == "眼睛闭合":
        return 0

    ear_avg = (ear_left + ear_right) / 2    # 左右眼EAR平均
    ear_asymmetry = abs(ear_left - ear_right)  # 左右眼不对称度

    # 阶梯式评分 —— 对应论文中"偏离基线越远，惩罚越大"
    if ear_avg >= 0.22:      # 最优
        base_score = 20
    elif ear_avg >= 0.20:    # 良好
        base_score = 16
    elif ear_avg >= 0.18:    # 一般
        base_score = 12
    elif ear_avg >= 0.16:    # 较差
        base_score = 6
    else:                     # 很差
        base_score = 0

    # 左右眼不对称惩罚（斜视/疲劳指标）
    if ear_asymmetry > 0.05:
        base_score -= min(5, ear_asymmetry * 20)

    # 稳定性奖励：最近30帧EAR标准差越小 → 奖励越多
    if len(self.ear_history) >= 30:
        ear_std = np.std(list(self.ear_history)[-30:])
        if ear_std < 0.02:   base_score += 3   # 非常稳定
        elif ear_std < 0.04: base_score += 2   # 稳定

    return max(0, base_score)  # 最终0-25分
```

**与公式13的对应：**
- `ear_avg` 就是 EAR_τ
- 阈值评分对应 (EAR_τ - EAR̄)² 的偏差度量
- 30帧的 `ear_std` 对应公式中滑动窗口 T 内的方差计算

---

### δ₂：视线稳定性偏离 → `calculate_gaze_score_optimized()`（第3623行）

**满分20分。视线偏离中心越远 → 得分越少。**

```python
def calculate_gaze_score_optimized(self, gaze_x, gaze_y, attention_label):
    if attention_label in ["视线偏离", "视线偏移"]:
        return 0

    # 视线偏移幅度 = sqrt(gaze_x² + gaze_y²)
    gaze_magnitude = math.sqrt(gaze_x ** 2 + gaze_y ** 2)

    # 阶梯评分
    if gaze_magnitude <= 0.15:    base_score = 15   # 最优
    elif gaze_magnitude <= 0.25:  base_score = 12   # 良好
    elif gaze_magnitude <= 0.35:  base_score = 9    # 一般
    elif gaze_magnitude <= 0.50:  base_score = 5    # 较差
    else:                          base_score = 0    # 很差

    # 惩罚快速扫视（前后帧视线变化过大）
    if len(self.gaze_history) >= 2:
        gaze_speed = abs(gaze_magnitude - self.gaze_history[-2])
        if gaze_speed > 0.8:
            base_score -= min(5, gaze_speed * 3)

    # 奖励长期稳定（60帧≈2秒内视线标准差小）
    if len(self.gaze_history) >= 60:
        gaze_std = np.std(list(self.gaze_history)[-60:])
        if gaze_std < 0.1:   base_score += 3
        elif gaze_std < 0.2: base_score += 2

    return max(0, base_score)  # 最终0-20分
```

**与公式13的对应：**
- `gaze_magnitude` 对应 ‖u_τ - ū‖ 中视线分量的偏差
- `gaze_speed` 对应时间维度上的变化率
- 60帧窗口的 `gaze_std` 对应公式中的滑动窗口方差

---

### δ₃：头部姿态偏离 → `calculate_head_score_optimized()`（第3665行）

**满分15分。头部偏转越大 → 得分越少。**

```python
def calculate_head_score_optimized(self, yaw, pitch, attention_label):
    # 头部偏移合成值 = sqrt(yaw² + pitch²)
    head_offset = math.sqrt(yaw ** 2 + pitch ** 2)

    # 阶梯评分
    if head_offset <= 8.0:    base_score = 12   # 最优
    elif head_offset <= 15.0: base_score = 10   # 良好
    elif head_offset <= 25.0: base_score = 8    # 一般
    elif head_offset <= 35.0: base_score = 4    # 较差
    else:                      base_score = 0

    # 惩罚快速转头（ADHD典型特征）
    if self.last_head_position is not None:
        prev_yaw, prev_pitch = self.last_head_position
        head_movement = math.sqrt(
            (yaw - prev_yaw)**2 + (pitch - prev_pitch)**2
        )
        if head_movement > 10.0:
            base_score -= min(4, head_movement * 2)

    # 奖励长期稳定（60帧窗口）
    if len(self.head_pose_history) >= 60:
        head_std = np.std(list(self.head_pose_history)[-60:])
        if head_std < 5.0:    base_score += 2
        elif head_std < 10.0: base_score += 1

    return max(0, base_score)  # 最终0-15分
```

**与公式13的对应：**
- `head_offset = sqrt(yaw² + pitch²)` 直接对应 ‖u_τ - ū‖，即头部姿态向量偏离基线的欧氏距离
- `head_movement`（帧间变化）对应公式中时序方差的思想
- 论文中的 ω_i（病理权重）在这里体现为满分上限15分（占总分15%）

---

### δ₄：持续专注时长 → `calculate_duration_score_optimized()`（第3718行）

**满分20分。持续专注越久 → 得分越高。这是ADHD的核心指标。**

```python
def calculate_duration_score_optimized(self, attention_label, current_time):
    if self.focus_start_time is None:
        return 5  # 无数据时给基础分

    focus_duration = current_time - self.focus_start_time  # 持续专注秒数

    if focus_duration >= 10.0:  return 18   # ≥10秒：优秀
    elif focus_duration >= 5.0: return 14   # ≥5秒：良好
    elif focus_duration >= 2.0: return 9    # ≥2秒：一般
    else:                        return 4    # <2秒：短暂
```

**说明：** 论文中没有直接给出"持续专注时长"的公式，但在Section 2.3.2的时间窗口 T 中隐含了这个概念。代码把它独立出来作为一个评分维度，因为对ADHD儿童来说这是最关键的指标。

---

### δ₅：眨眼模式 → `calculate_blink_score_optimized()`（第3735行）

**满分10分。眨眼频率在正常范围内得高分，过快或过慢都扣分。**

```python
def calculate_blink_score_optimized(self, ear_left, ear_right, current_time):
    # 计算最近10秒的眨眼频率（转换为次/分钟）
    recent_timestamps = [ts for ts in self.blink_timestamps
                         if current_time - ts <= 10]
    blink_rate = len(recent_timestamps) / 10.0 * 60

    # 正常范围10-30次/分钟
    if 10 <= blink_rate <= 30:    base_score = 8   # 正常
    elif blink_rate > 40:          base_score = 3   # 过快（焦虑/疲劳）
    elif blink_rate < 5:           base_score = 4   # 过慢（过度专注/疲劳）
    else:                           base_score = 6   # 略偏

    # 连续快速眨眼簇惩罚（ADHD压力指标）
    if len(self.blink_clusters) > 0 and self.blink_clusters[-1] >= 3:
        base_score -= 2

    return max(0, base_score)  # 最终0-10分
```

**与论文的对应：** 对应论文Section 2.3.1中提到的"区分生理性眨眼和异常眨眼簇"。

---

### δ₆：运动躁动度 → `calculate_motor_score()`（第3781行）

**满分10分。微动作越频繁 → 得分越低（多动症过度活动特征）。**

```python
def calculate_motor_score(self, yaw, pitch, current_time):
    # 计算帧间头部微小移动
    prev_yaw, prev_pitch = self.last_head_position
    movement = math.sqrt((yaw - prev_yaw)**2 + (pitch - prev_pitch)**2)

    # 记录微小动作（幅度0.5-5.0度的范围）
    if 0.5 < movement < 5.0:
        self.micro_movement_count += 1
        self.motor_movements.append({"timestamp": current_time, ...})

    # 计算最近5秒的微动频率
    recent = [m for m in self.motor_movements
              if current_time - m["timestamp"] <= 5]
    movement_freq = len(recent) / 5.0  # 次/秒

    base_score = 8
    if movement_freq > 3.0:    base_score -= 4  # 明显躁动
    elif movement_freq > 1.5:  base_score -= 2  # 中度躁动

    return max(0, base_score)  # 最终0-10分
```

**与论文的对应：** 对应论文Section 2.1中提到的"body micromotion"（身体微动）行为指标。

---

## 第三项：λΣη_j · ŷ_j(t)（情绪校正项）

**论文含义：** 焦虑、困惑等情绪可能导致非病理性的行为异常，需要通过情绪识别结果来校正注意力评分。η_j 是第 j 类情绪的调整系数，ŷ_j 是该类情绪的置信概率，λ 是情绪影响总权重。

**代码位置：** `calculate_emotion_adjustment_optimized()`（第3821行）

```python
def calculate_emotion_adjustment_optimized(self, emotion_state, attention_label):
    emotion = emotion_state.get("emotion", "中性")       # 当前情绪类别
    confidence = emotion_state.get("confidence", 0)      # ŷ_j：置信概率

    # η_j：每种情绪的调整系数
    emotion_effects = {
        "生气": -10,    # 生气 → 注意力更差
        "恐惧": -8,     # 恐惧 → 注意力分散
        "悲伤": -6,     # 悲伤 → 影响注意力维持
        "厌恶": -4,     # 厌恶 → 有负面影响
        "中性":  0,     # 中性 → 最利于注意力（不调整）
        "惊讶": +3,     # 惊讶 → 短暂提高注意力
        "快乐": +6      # 快乐 → 有助于注意力
    }

    base_adjustment = emotion_effects.get(emotion, 0)  # η_j

    # λ·η_j·ŷ_j(t) → 系数 × 置信度
    adjusted = base_adjustment * confidence

    # 额外奖励：快乐+专注
    if emotion == "快乐" and attention_label == "专注":
        adjusted += 2

    return adjusted
```

**公式对应关系：**

| 公式符号 | 代码实现 | 具体值 |
|---------|---------|-------|
| N = 7 | `emotion_effects` 字典的7个键 | 生气/厌恶/恐惧/快乐/悲伤/惊讶/中性 |
| η_j | `emotion_effects[emotion]` | -10, -8, -6, -4, 0, +3, +6 |
| ŷ_j(t) | `confidence` | DAF-Xception模型输出的最大类别置信度 |
| λ | 隐含为1.0 | 代码中没有额外的λ系数，直接相乘 |
| λ·η_j·ŷ_j(t) | `base_adjustment * confidence` | 例如：生气+置信度0.9 → -10×0.9 = -9分 |

**注意：** 代码做了一个简化——论文公式是对所有7类情绪求加权和（Σ），但代码只取了**置信度最高的那一类情绪**来计算调整值。这是因为 `EmotionAnalyzer` 只返回 argmax 后的单一情绪类别和其置信度。

---

## 额外项：ADHD特征调整（论文中未单独列出）

代码在公式14的基础上增加了一个**ADHD特征惩罚项**：

```python
# 第3541行
adhd_adjustment = self.detect_adhd_features(
    attention_state, emotion_state, current_time
)
```

这个函数检测三种ADHD典型行为模式并额外扣分：

| 检测项 | 条件 | 扣分 |
|-------|------|------|
| 连续分心 | 最近3帧全部非"专注" | -5 |
| 情绪波动 | 30秒内出现≥3次生气/恐惧 | -4 |
| 注意力频繁转移 | 20帧内"分心→专注"切换≥5次 | -3 |

---

## 最后一步：非线性缩放

公式14计算完成后，代码还对分数做了一次非线性变换（第3904行）：

```python
def apply_nonlinear_scaling(self, score):
    if score >= 80:
        return 80 + (score - 80) * 0.8    # 高分段压缩（不容易拿满分）
    elif score >= 60:
        return score                        # 中间段保持线性
    elif score >= 40:
        return 40 + (score - 40) * 1.2     # 低分段放大差异
    else:
        return score * 1.5                  # 极低分段进一步放大
```

目的：让注意力评分在**关键临界区域（40-60分）**更敏感，便于教师判断学生状态变化。

---

## 完整计算流程图

```
输入：attention_state + emotion_state
│
├── eye_score    = f(EAR左, EAR右, 不对称度, 稳定性)     → 0~25分
├── gaze_score   = f(视线偏移, 移动速度, 长期稳定性)       → 0~20分
├── head_score   = f(头部偏转, 移动速度, 长期稳定性)       → 0~15分
├── duration_score = f(持续专注秒数)                       → 0~20分
├── blink_score  = f(眨眼频率, 眨眼簇)                    → 0~10分
└── motor_score  = f(微动频率)                             → 0~10分
│
├── base_score = 以上6项之和                               → 0~100分
│                                                 （等价于 S_base - Σδ_{i,t}）
│
├── emotion_adjustment = η_j × confidence                 → -10 ~ +8
│                                                 （等价于 -λΣη_j·ŷ_j(t)）
│
├── adhd_adjustment = ADHD行为模式惩罚                    → -12 ~ 0
│                                                 （代码额外增加的项）
│
├── total = base_score + emotion_adjustment + adhd_adjustment
│
├── total = apply_nonlinear_scaling(total)               → 非线性变换
│
└── final_score = clip(total, 0, 100)                    → 最终输出
```
